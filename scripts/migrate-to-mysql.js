// JSON m…ôlumatlarƒ±nƒ± MySQL-…ô k√∂√ß√ºrm…ôk √º√ß√ºn migration script
const mysql = require('mysql2/promise');
const fs = require('fs').promises;
const path = require('path');
const bcrypt = require('bcryptjs');

// Environment variables
require('dotenv').config();

class MySQLMigration {
    constructor() {
        this.connection = null;
        this.dataPath = path.join(__dirname, '..', 'data');
    }

    // MySQL baƒülantƒ±sƒ±
    async connect() {
        try {
            this.connection = await mysql.createConnection({
                host: process.env.DB_HOST || 'localhost',
                port: process.env.DB_PORT || 3306,
                user: process.env.DB_USER,
                password: process.env.DB_PASSWORD,
                database: process.env.DB_NAME,
                charset: 'utf8mb4'
            });
            
            console.log('‚úÖ MySQL baƒülantƒ±sƒ± uƒüurlu');
            return true;
        } catch (error) {
            console.error('‚ùå MySQL baƒülantƒ± x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // JSON fayl oxuma
    async readJSONFile(filename) {
        try {
            const filePath = path.join(this.dataPath, filename);
            const data = await fs.readFile(filePath, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            console.error(`JSON fayl oxuma x…ôtasƒ± (${filename}):`, error.message);
            return [];
        }
    }

    // C…ôdv…ôll…ôri yaratma
    async createTables() {
        try {
            console.log('üîÑ C…ôdv…ôll…ôr yaradƒ±lƒ±r...');

            // Products c…ôdv…ôli
            await this.connection.execute(`
                CREATE TABLE IF NOT EXISTS products (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    name VARCHAR(255) NOT NULL,
                    description TEXT,
                    price DECIMAL(10,2),
                    category VARCHAR(100),
                    brand VARCHAR(100),
                    image VARCHAR(255),
                    stock INT DEFAULT 0,
                    sku VARCHAR(100),
                    weight DECIMAL(8,2),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_category (category),
                    INDEX idx_brand (brand),
                    INDEX idx_price (price)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            `);

            // Brands c…ôdv…ôli
            await this.connection.execute(`
                CREATE TABLE IF NOT EXISTS brands (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    name VARCHAR(255) NOT NULL UNIQUE,
                    description TEXT,
                    logo VARCHAR(255),
                    website VARCHAR(255),
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_name (name)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            `);

            // Categories c…ôdv…ôli
            await this.connection.execute(`
                CREATE TABLE IF NOT EXISTS categories (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    name VARCHAR(255) NOT NULL UNIQUE,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_name (name)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            `);

            // Users c…ôdv…ôli
            await this.connection.execute(`
                CREATE TABLE IF NOT EXISTS users (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    username VARCHAR(100) UNIQUE NOT NULL,
                    email VARCHAR(255) UNIQUE NOT NULL,
                    password VARCHAR(255) NOT NULL,
                    role ENUM('admin', 'user') DEFAULT 'user',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    INDEX idx_username (username),
                    INDEX idx_email (email)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            `);

            // Featured Products c…ôdv…ôli
            await this.connection.execute(`
                CREATE TABLE IF NOT EXISTS featured_products (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    product_id INT,
                    order_index INT DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
                    INDEX idx_order (order_index)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            `);

            console.log('‚úÖ B√ºt√ºn c…ôdv…ôll…ôr yaradƒ±ldƒ±');
            return true;
        } catch (error) {
            console.error('‚ùå C…ôdv…ôl yaratma x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // Brendl…ôri k√∂√ß√ºrm…ô
    async migrateBrands() {
        try {
            console.log('üîÑ Brendl…ôr k√∂√ß√ºr√ºl√ºr...');
            const brands = await this.readJSONFile('brands.json');
            
            for (const brand of brands) {
                await this.connection.execute(
                    'INSERT IGNORE INTO brands (name, description, logo, website) VALUES (?, ?, ?, ?)',
                    [brand.name, brand.description || null, brand.logo || null, brand.website || null]
                );
            }
            
            console.log(`‚úÖ ${brands.length} brend k√∂√ß√ºr√ºld√º`);
            return true;
        } catch (error) {
            console.error('‚ùå Brend k√∂√ß√ºrm…ô x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // Kateqoriyalarƒ± k√∂√ß√ºrm…ô
    async migrateCategories() {
        try {
            console.log('üîÑ Kateqoriyalar k√∂√ß√ºr√ºl√ºr...');
            const categories = await this.readJSONFile('categories.json');
            
            for (const category of categories) {
                await this.connection.execute(
                    'INSERT IGNORE INTO categories (name, description) VALUES (?, ?)',
                    [category.name, category.description || null]
                );
            }
            
            console.log(`‚úÖ ${categories.length} kateqoriya k√∂√ß√ºr√ºld√º`);
            return true;
        } catch (error) {
            console.error('‚ùå Kateqoriya k√∂√ß√ºrm…ô x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // M…ôhsullarƒ± k√∂√ß√ºrm…ô
    async migrateProducts() {
        try {
            console.log('üîÑ M…ôhsullar k√∂√ß√ºr√ºl√ºr...');
            const products = await this.readJSONFile('products.json');
            
            for (const product of products) {
                await this.connection.execute(`
                    INSERT IGNORE INTO products 
                    (name, description, price, category, brand, image, stock, sku, weight) 
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [
                    product.name,
                    product.description || null,
                    product.price || 0,
                    product.category || null,
                    product.brand || null,
                    product.image || null,
                    product.stock || 0,
                    product.sku || null,
                    product.weight || null
                ]);
            }
            
            console.log(`‚úÖ ${products.length} m…ôhsul k√∂√ß√ºr√ºld√º`);
            return true;
        } catch (error) {
            console.error('‚ùå M…ôhsul k√∂√ß√ºrm…ô x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // ƒ∞stifad…ô√ßil…ôri k√∂√ß√ºrm…ô
    async migrateUsers() {
        try {
            console.log('üîÑ ƒ∞stifad…ô√ßil…ôr k√∂√ß√ºr√ºl√ºr...');
            const users = await this.readJSONFile('users.json');
            
            for (const user of users) {
                // ≈ûifr…ôni hash-l…ô (…ôg…ôr artƒ±q hash-l…ônm…ôyibs…ô)
                let hashedPassword = user.password;
                if (!user.password.startsWith('$2')) {
                    hashedPassword = await bcrypt.hash(user.password, 12);
                }
                
                await this.connection.execute(
                    'INSERT IGNORE INTO users (username, email, password, role) VALUES (?, ?, ?, ?)',
                    [user.username, user.email, hashedPassword, user.role || 'user']
                );
            }
            
            console.log(`‚úÖ ${users.length} istifad…ô√ßi k√∂√ß√ºr√ºld√º`);
            return true;
        } catch (error) {
            console.error('‚ùå ƒ∞stifad…ô√ßi k√∂√ß√ºrm…ô x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // Se√ßilmi≈ü m…ôhsullarƒ± k√∂√ß√ºrm…ô
    async migrateFeaturedProducts() {
        try {
            console.log('üîÑ Se√ßilmi≈ü m…ôhsullar k√∂√ß√ºr√ºl√ºr...');
            const featuredProducts = await this.readJSONFile('featured-products.json');
            const products = await this.readJSONFile('products.json');
            
            for (const fp of featuredProducts) {
                // JSON-da productId il…ô MySQL-d…ô id tapƒ±rƒ±q
                const product = products.find(p => p._id === fp.productId || p.id === fp.productId);
                if (product) {
                    // MySQL-d…ô h…ômin m…ôhsulun ID-sini tapƒ±rƒ±q
                    const [rows] = await this.connection.execute(
                        'SELECT id FROM products WHERE name = ? LIMIT 1',
                        [product.name]
                    );
                    
                    if (rows.length > 0) {
                        await this.connection.execute(
                            'INSERT IGNORE INTO featured_products (product_id, order_index) VALUES (?, ?)',
                            [rows[0].id, fp.order || 0]
                        );
                    }
                }
            }
            
            console.log(`‚úÖ ${featuredProducts.length} se√ßilmi≈ü m…ôhsul k√∂√ß√ºr√ºld√º`);
            return true;
        } catch (error) {
            console.error('‚ùå Se√ßilmi≈ü m…ôhsul k√∂√ß√ºrm…ô x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // Default admin istifad…ô√ßisi yaratma
    async createDefaultAdmin() {
        try {
            console.log('üîÑ Default admin yaradƒ±lƒ±r...');
            
            const adminUsername = process.env.DEFAULT_ADMIN_USERNAME || 'admin';
            const adminPassword = process.env.DEFAULT_ADMIN_PASSWORD || 'admin123';
            const adminEmail = process.env.ADMIN_EMAIL || 'admin@oldbridge.az';
            
            const hashedPassword = await bcrypt.hash(adminPassword, 12);
            
            await this.connection.execute(`
                INSERT IGNORE INTO users (username, email, password, role) 
                VALUES (?, ?, ?, 'admin')
            `, [adminUsername, adminEmail, hashedPassword]);
            
            console.log(`‚úÖ Default admin yaradƒ±ldƒ±: ${adminUsername}`);
            return true;
        } catch (error) {
            console.error('‚ùå Default admin yaratma x…ôtasƒ±:', error.message);
            return false;
        }
    }

    // B√ºt√ºn migration prosesi
    async runMigration() {
        console.log('üöÄ MySQL Migration ba≈ülayƒ±r...');
        console.log('=' .repeat(50));
        
        // Baƒülantƒ±
        if (!(await this.connect())) {
            return false;
        }
        
        // C…ôdv…ôll…ôri yarat
        if (!(await this.createTables())) {
            return false;
        }
        
        // M…ôlumatlarƒ± k√∂√ß√ºr
        await this.migrateBrands();
        await this.migrateCategories();
        await this.migrateProducts();
        await this.migrateUsers();
        await this.migrateFeaturedProducts();
        await this.createDefaultAdmin();
        
        console.log('=' .repeat(50));
        console.log('üéâ Migration tamamlandƒ±!');
        console.log('‚úÖ Artƒ±q .env faylƒ±nda DB_TYPE=mysql t…ôyin ed…ô bil…ôrsiniz');
        
        return true;
    }

    // Baƒülantƒ±nƒ± baƒülama
    async close() {
        if (this.connection) {
            await this.connection.end();
            console.log('‚úÖ MySQL baƒülantƒ±sƒ± baƒülandƒ±');
        }
    }
}

// Script i≈ü…ô salma
async function main() {
    const migration = new MySQLMigration();
    
    try {
        await migration.runMigration();
    } catch (error) {
        console.error('‚ùå Migration x…ôtasƒ±:', error.message);
    } finally {
        await migration.close();
        process.exit(0);
    }
}

// ∆èg…ôr bu fayl birba≈üa i≈ü…ô salƒ±nƒ±rsa
if (require.main === module) {
    main();
}

module.exports = MySQLMigration;